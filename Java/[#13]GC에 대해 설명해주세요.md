가비지 컬렉터는 동적으로 할당된 메모리 영역을 자동으로 해제해주는 기능입니다.

GC는 새로 생성된 객체들의 대부분이 금방 참조대상에서 제외되고 오래된 객체는 새로 생성된 객체를 참조하는 경우가 적다는 가정을 기반으로 고안되었습니다. 

일반적으로 JVM에는 GC를 담당하는 쓰레드가 할당이 되어 있으며, 이를 가비지 컬렉터라고 부르기도 합니다.

GC가 돌아가는 방식을 이해하려면 JVM의 힙영역, 정확하게는 Runtime Data Area에서의 Heap영역의 구조를 이해할 필요가 있습니다. 

<img src="https://1.bp.blogspot.com/-MoOVJsk6fEc/VJmLWYxfgEI/AAAAAAAACQE/jggByJMXWhw/s1600/Java%2BHeap.PNG">

Eden, S0, S1영역을 Young Generation, Tenured영역을 Old Generation, 그리고 Permananent 영역을 Permanent Generation이라고 부를 수 있습니다.

프로그램이 실행하는 도중에 생성되는 객체들은 에덴 영역에 할당이 되고 적재됩니다. 그러다가 에덴 영역의 공간이 특정 퍼센트 이상 차게 되면 Minor GC가 일어나고, 이때 S0이 차있으면 S1으로, 반대로 S1가 차있으면 S0으로 살아남은 객체들이 이동합니다. 

이러한 과정이 몇번 반복된 이후에도 살아남은 객체들은 Old Generation으로 이동하게 되고, Teunured 영역이 일정 비율 이상 차게 되면 Major GC가 일어납니다. 

Permanent 영역에는 JVM 메타데이터가 주로 저장되는데 이 부분은 Minor GC와 Major GC를 함께 진행하는 Full GC때 수거됩니다.

가비지 컬렉션에 치명적인 단점 중 하나는 GC를 할 때에 기존 프로그램의 로직은 잠깐 돌아가지 않는다는 점입니다. 세상이 멈춘다는 식으로 이를 Stop the World가 일어난다고 표현하는데 그렇기 때문에 가비지 컬렉션에 소요되는 시간을 최대한 단축하는 것이 중요합니다. 나이브하게는 Reference Counting, Mark and Sweep, 그리고 이를 최적화한 다양한 알고리즘이 등장한 것도 GC에 드는 시간을 최소화하기 위함입니다.