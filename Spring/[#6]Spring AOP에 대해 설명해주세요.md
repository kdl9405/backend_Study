우선 Spring AOP를 설명하기 위해서는 AOP를 설명해야 합니다. 

AOP(Aspect Oriented Programming)을 한마디로 요약하면 로직 주입입니다. 이 때 아무 로직을 주입하지는 않고, 여러 코드에서 반복적으로 나타나고, 비즈니스의 로직과의 응집도가 떨어지는 로직을 주입합니다. AOP에서 흔히 나타나는 용어들이 있습니다. 

* JoinPoint - 로직 적용이 가능한 대상들
* Pointcut - 로직을 주입할 대상들
* Advice - 어떤 로직을 언제 주입할지(대상 실행 이전, 실행 이후, 혹은 전후 등)

이런 측면에서 보았을 때 Aspect = Pointcut + Advice이다. 이를 기반해서 AOP를 다시 설명하면, 이미 만들어진 어떤 대상들의 어떤 시점에 어떤 로직을 주입할지에 초점을 맞추는 프로그래밍 기법이라고 할 수 있다. 그렇기 때문에 메서드의 실행시간을 측정하거나 로그를 찍는 등의 행위를 AOP를 통해서 많이 실행하는 것이다.

AOP가 컴파일타임이나 로드타임에 실제로 코드를 주입하는 것과 달리, Spring AOP는 런타임에 프록시 객체에 주입할 로직을 두고 실제 타깃을 호출한다. 이때, 스프링 AOP의 구현체는 두 가지로 나뉜다. 왜 런타임에 하는지를 궁금해할 수 있는데, 스프링은 빈을 통해서 프록시패턴을 구현하고 빈이 담긴 ioc container를 통해서 프로그램의 동작을 관리하기 때문에 런타임에 하는 것이 어울린다.  

먼저 인터페이스에 적용되는 JDK Dynamic Proxy방식이 있다. 인터페이스를 구현하는 것으로 프록시객체를 만들고 Pointcut에 advice를 적용하는 방식이다.

다음으로 클래스의 바이트코드를 조작하는 CGLib(Code Generator Library) 방식이 있다. 대상객체를 상속받아서 public한 pointcut들에 advice를 적용하는 방식이다. 상속을 받기 때문에 final로 선언한 객체에는 적용할 수 없다는 단점이 있다.

하지만, 두 가지 방식 모두 self-invocation, 즉 메서드 내부에서 클래스 내부의 다른 메서드를 호출할 경우 로직 주입이 첫번째 메서드에만 주입된다는 단점이 있다. 프록시객체가 그렇듯 실제 타깃으로의 호출이 일어나면 그 뒤부터는 실제 대상의 로직을 그대로 따르기 때문에 그렇다. 이를 해결하는 방법 또한 여러 가지가 있는데, 그 중 하나는 Weaving이다. Aspect들을 엮어서 내부에서 호출이 일어났을 때에도 aspect를 거치도록 하는 방식으로 이 또한 컴파일타임, 로드타임, 런타임에 가능하지만 Spring AOP는 런타임에 weaving한다.